# 영화관 예매 시스템 개발 규칙 (Development Rules)

## 1. 절대 원칙 (Absolute Principles)

### 1.1 좌석 상태 변경 제어
- **좌석 상태 변경은 단일 진입점만 허용**
  - 좌석 상태 변경은 `SeatCommandService` (혹은 이에 준하는 Command Layer) 외 호출 금지
  - 다른 레이어에서 좌석 상태를 직접 변경하는 것은 절대 금지

### 1.2 데이터 저장소 역할 분리
- **Redis → DB 직접 수정 금지**
  - Redis는 캐시/락/HOLD 용도로만 사용
  - DB는 최종 진실(Source of Truth)
  - Redis의 데이터는 일시적이며, DB가 최종 상태를 결정

### 1.3 클라이언트 신뢰 금지
- **좌석 상태, 가격, 영화 정보는 서버 계산값만 신뢰**
  - 클라이언트에서 전달된 좌석 상태, 가격 정보는 절대 신뢰하지 않음
  - 모든 비즈니스 로직과 상태 계산은 서버에서 수행

### 1.4 비동기 이벤트 멱등성
- **비동기 이벤트는 멱등성 보장 필수**
  - 동일 이벤트가 여러 번 처리되어도 결과가 동일해야 함
  - 이벤트 ID 기반 중복 처리 방지 필수

## 2. 아키텍처 레이어 규칙

### 2.1 레이어 의존성 규칙
```
Controller → Application(Service) → Domain → Infrastructure
```
- **역방향 의존 절대 금지**
  - 상위 레이어는 하위 레이어에만 의존
  - Domain Layer는 Infrastructure Layer를 직접 참조하지 않음
  - Infrastructure는 Domain의 인터페이스를 구현

### 2.2 Domain Layer 규칙
- **Spring Annotation 사용 금지**
  - Domain Layer는 프레임워크에 독립적이어야 함
  - `@Entity`, `@Component` 등 Spring 어노테이션 사용 금지

- **Redis / JPA / HTTP 참조 금지**
  - Domain Layer는 인프라스트럭처 기술에 대한 지식이 없어야 함
  - 순수 Java 객체로만 구성

## 3. Domain 규칙

### 3.1 Aggregate 규칙
- **Aggregate Root 외 Entity 직접 접근 금지**
  - 모든 Entity 접근은 Aggregate Root를 통해서만 가능
  - 외부에서 내부 Entity에 직접 접근하는 것은 금지

### 3.2 좌석 소속 규칙
- **좌석은 반드시 Screening Aggregate 소속**
  - 좌석은 독립적인 Aggregate가 아님
  - Screening Aggregate의 일부로 관리

### 3.3 가격 계산 규칙
- **가격 계산은 Domain Service에서만 수행**
  - 가격 계산 로직은 Domain Service에 위치
  - Application Service나 Infrastructure에서 가격 계산 금지

## 4. 좌석 상태 관리 규칙

### 4.1 좌석 상태 정의
좌석 상태는 단일 Enum으로 정의하며, 다음 3가지 상태만 허용:

```java
public enum SeatStatus {
    AVAILABLE,  // 예매 가능
    HOLD,       // 임시 보류 (결제 대기 중)
    RESERVED    // 예매 완료
}
```

- **임의 상태 추가 금지**
  - 위 3가지 상태 외 추가 상태는 절대 금지
  - 상태 전이는 명확한 비즈니스 규칙에 따라만 가능

### 4.2 HOLD 규칙

#### 4.2.1 HOLD 필수 요구사항
- **HOLD는 반드시 Redis + TTL 사용**
  - HOLD 상태는 Redis에 저장되며, 반드시 TTL 설정
  - TTL 없는 HOLD Key 생성 금지

- **HOLD Token 발급 필수**
  - 좌석 HOLD 시 반드시 고유한 HOLD Token 발급
  - HOLD Token은 UUID 또는 암호화된 토큰 사용

- **HOLD Token 없는 요청은 무조건 실패**
  - 좌석 예매/결제 시 HOLD Token 검증 필수
  - HOLD Token이 없거나 유효하지 않으면 요청 거부

#### 4.2.2 HOLD 연장 규칙
- **동일 유저라도 HOLD 연장 불가 (재선택 필요)**
  - HOLD 시간 연장은 불가능
  - TTL 만료 후 자동 해제되며, 재선택 필요

### 4.3 분산 락 규칙

#### 4.3.1 락 키 규칙
```
lock:screening:{screeningId}:seat:{seatId}
```
- 락 키는 상영 ID와 좌석 ID를 포함하여 명확하게 식별

#### 4.3.2 락 획득 실패 처리
- **락 획득 실패 시 즉시 실패 응답**
  - 락 획득 실패 시 재시도하지 않음
  - 서버에서 재시도 로직 구현 금지

- **재시도 로직은 클라이언트 책임**
  - 클라이언트에서 필요 시 재시도 처리
  - 서버는 단순히 실패 응답만 반환

## 5. 트랜잭션 규칙

### 5.1 트랜잭션 범위
- **결제 성공 → DB 커밋 → Redis 정리**
  - 결제 성공 후 DB에 먼저 커밋
  - DB 커밋 성공 후 Redis에서 HOLD 정보 정리
  - 순서: 결제 검증 → DB 저장 → Redis 정리

- **Redis 성공을 기준으로 DB를 커밋하지 않음**
  - DB가 최종 진실이므로, Redis 상태와 무관하게 DB 커밋 결정
  - Redis 실패해도 DB 커밋은 정상 진행

### 5.2 트랜잭션 금지 사항
- **Controller에서 @Transactional 금지**
  - 트랜잭션은 Application Service 레이어에서만 관리
  - Controller는 트랜잭션 경계를 설정하지 않음

- **이벤트 리스너에서 신규 트랜잭션 생성 시 명시 필수**
  - 이벤트 리스너에서 트랜잭션이 필요한 경우 `@Transactional(propagation = Propagation.REQUIRES_NEW)` 명시
  - 기본 트랜잭션 전파 방식 사용 금지

## 6. 실시간 좌석 갱신 규칙

### 6.1 통신 방식
- **Polling 금지**
  - 클라이언트에서 주기적으로 서버에 요청하는 방식 금지
  - 서버 부하 및 실시간성 저하 방지

- **WebSocket / SSE 중 택1 (혼용 금지)**
  - WebSocket 또는 Server-Sent Events(SSE) 중 하나만 선택
  - 두 방식을 혼용하여 사용하지 않음
  - 프로젝트 전반에 걸쳐 일관된 방식 사용

### 6.2 이벤트 기준
- **좌석 상태 변경 시만 Push**
  - 좌석 상태가 실제로 변경된 경우에만 클라이언트에 Push
  - 불필요한 이벤트 전송 금지

- **전체 좌석 재전송 금지**
  - 변경된 좌석 정보만 전송
  - 전체 좌석 맵을 매번 전송하지 않음

- **변경 좌석 ID만 전달**
  - 이벤트 페이로드는 변경된 좌석 ID와 상태만 포함
  - 네트워크 대역폭 최적화

## 7. Redis 사용 규칙

### 7.1 Key 네이밍 규칙
```
seat:hold:{screeningId}:{seatId}      # HOLD 정보
seat:status:{screeningId}              # 좌석 상태 캐시
lock:seat:{screeningId}:{seatId}       # 분산 락
```
- Key 네이밍은 일관된 패턴 유지
- 콜론(`:`)을 구분자로 사용하여 계층 구조 표현

### 7.2 TTL 규칙
- **HOLD TTL: 설정값 기반 (5~10분)**
  - HOLD TTL은 설정 파일에서 관리
  - 기본값: 5~10분 (PRD 기준)
  - 환경별로 조정 가능

- **TTL 없는 HOLD Key 생성 금지**
  - 모든 HOLD Key는 반드시 TTL 설정
  - TTL이 없으면 메모리 누수 및 좌석 상태 불일치 발생 가능

## 8. 성능 규칙

### 8.1 응답 시간 목표
- **좌석 클릭 → 반영 < 200ms**
  - 좌석 클릭 후 서버 응답까지 200ms 이내
  - Redis 조회, 분산 락 획득, 상태 업데이트 최적화

### 8.2 동시성 제어
- **최대 1000 TPS 지원**
  - 분산 락과 Redis를 활용하여 동시성 제어
  - 피크타임(주말, 공휴일, 인기 영화 개봉일) 대응

## 9. 보안 규칙

### 9.1 인증
- **JWT Access Token 유효시간 ≤ 15분**
  - Access Token은 짧은 유효시간 유지
  - 보안 강화 및 토큰 탈취 시 피해 최소화

- **Refresh Token은 Redis 저장**
  - Refresh Token은 Redis에 저장하여 관리
  - 토큰 무효화 및 세션 관리 용이

### 9.2 관리자 API
- **`/admin/**` 는 Role 기반 접근 필수**
  - 관리자 API는 반드시 역할(Role) 기반 접근 제어
  - 일반 사용자는 접근 불가

- **관리자 API는 별도 Rate Limit 적용**
  - 관리자 API는 일반 API와 별도의 Rate Limit 정책 적용
  - 더 엄격한 제한 가능

### 9.3 API Rate Limit
- **예매 API Rate Limit 필수**
  - 좌석 예매 관련 API는 Rate Limit 적용
  - 악의적 요청 및 서버 부하 방지

### 9.4 HOLD Token 검증
- **HOLD Token 검증 필수**
  - 모든 좌석 관련 요청에서 HOLD Token 검증
  - 위변조 방지 및 보안 강화

## 10. 결제 규칙

### 10.1 Mock 결제
- **결제는 Mock 시스템 사용**
  - 실제 결제 게이트웨이 연동 없이 Mock 결제 사용
  - 개발 및 테스트 환경에서 사용

### 10.2 결제 실패 처리
- **결제 실패 시 HOLD된 좌석은 자동으로 해제**
  - 결제 실패 이벤트 발생 시 HOLD 자동 해제
  - 사용자에게 재시도 옵션 제공

### 10.3 결제 위변조 방지
- **결제 정보는 서버에서만 검증**
  - 클라이언트에서 전달된 결제 정보는 신뢰하지 않음
  - 가격, 좌석 정보는 서버에서 재계산하여 검증

## 11. 로깅 규칙

### 11.1 필수 로그
다음 이벤트는 반드시 로깅:
- 좌석 HOLD / 해제
- 결제 성공 / 실패
- 락 획득 실패
- 장애 발생 시점 및 원인

### 11.2 로그 금지
다음 정보는 로그에 기록하지 않음:
- 개인정보 (이름, 전화번호, 이메일 등)
- 결제 상세 정보 (카드 번호, 계좌 정보 등)
- JWT Token 전체 값 (일부만 마스킹하여 기록)

## 12. 프론트엔드 규칙 (Web / Mobile 공통)

### 12.1 상태 관리
- **서버 상태는 반드시 서버 기준**
  - 클라이언트의 상태는 서버 상태의 반영일 뿐
  - 서버와 클라이언트 상태 불일치 시 서버 상태가 우선

- **Optimistic UI 사용 시 롤백 로직 필수**
  - 낙관적 UI 업데이트 사용 시, 실패할 경우 롤백 로직 필수
  - 사용자 경험과 데이터 일관성 모두 보장

### 12.2 좌석 UI
- **선택 가능 / HOLD / RESERVED 시각적 명확 분리**
  - 좌석 상태별로 명확한 시각적 구분
  - 사용자가 현재 상태를 쉽게 인지할 수 있어야 함

- **HOLD 타이머는 서버 기준 시간 사용**
  - 클라이언트 시간이 아닌 서버 시간 기준으로 타이머 표시
  - 시간 동기화 문제 방지

### 12.3 좌석 맵 렌더링
- **Canvas / SVG 렌더링 사용**
  - 성능 최적화를 위해 Canvas 또는 SVG 사용
  - DOM 조작 최소화

## 13. 장애 대응 규칙

### 13.1 Redis 장애 대응
- **읽기: DB Fallback**
  - Redis 장애 시 좌석 상태 조회는 DB에서 수행
  - 읽기 성능 저하를 감수하더라도 서비스 지속

- **쓰기: 예매 차단 (Fail Fast)**
  - Redis 장애 시 새로운 예매는 차단
  - 데이터 일관성 보장을 위해 쓰기 작업 중단

### 13.2 자동 복구
- **장애 발생 시 좌석 상태 자동 복구 로직 필수**
  - HOLD 타임아웃 자동 해제
  - 트랜잭션 롤백을 통한 일관성 보장
  - 정기적인 상태 동기화 작업

## 14. 금지 사항 요약 (Blacklist)

다음 사항은 절대 금지:

1. **좌석 상태를 클라이언트에서 계산**
   - 모든 좌석 상태는 서버에서만 결정

2. **DB 없이 Redis만 신뢰**
   - Redis는 캐시일 뿐, DB가 최종 진실

3. **분산 락 없이 좌석 변경**
   - 동시성 제어 없이 좌석 상태 변경 금지

4. **테스트 없는 좌석/결제 로직 배포**
   - 핵심 비즈니스 로직은 반드시 테스트 커버리지 확보

5. **관리자 API 인증 생략**
   - 모든 관리자 API는 인증 및 권한 검사 필수

6. **Controller에서 트랜잭션 관리**
   - 트랜잭션은 Application Service에서만 관리

7. **Domain Layer에 Spring Annotation 사용**
   - Domain Layer는 프레임워크 독립적 유지

8. **Polling 방식 사용**
   - 실시간 갱신은 WebSocket 또는 SSE 사용

9. **전체 좌석 맵 재전송**
   - 변경된 좌석 정보만 전송

10. **TTL 없는 HOLD Key 생성**
    - 모든 HOLD Key는 반드시 TTL 설정

## 15. 코드 리뷰 체크리스트

코드 리뷰 시 다음 사항을 반드시 확인:

- [ ] 좌석 상태 변경이 `SeatCommandService`를 통해서만 이루어지는가?
- [ ] Domain Layer에 Spring Annotation이 없는가?
- [ ] 분산 락이 좌석 변경 시 사용되는가?
- [ ] HOLD Token 검증이 이루어지는가?
- [ ] 트랜잭션이 Controller가 아닌 Service에서 관리되는가?
- [ ] Redis Key 네이밍 규칙을 준수하는가?
- [ ] TTL이 모든 HOLD Key에 설정되어 있는가?
- [ ] 비동기 이벤트가 멱등성을 보장하는가?
- [ ] 개인정보가 로그에 기록되지 않는가?
- [ ] 관리자 API에 인증 및 권한 검사가 있는가?

## 16. 참고사항

- 본 규칙은 PRD.md의 요구사항을 기반으로 작성되었습니다.
- 규칙 위반 시 코드 리뷰에서 반드시 지적하고 수정을 요구합니다.
- 새로운 요구사항 발생 시 본 규칙 문서를 업데이트합니다.
- 모든 개발자는 본 규칙을 숙지하고 준수해야 합니다.
